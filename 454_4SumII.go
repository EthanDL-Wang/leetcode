/***********************************************************************************************************
*执行用时：72 ms, 在所有 Go 提交中击败了71.18%的用户
*内存消耗：25.6 MB, 在所有 Go 提交中击败了28.89%的用户
*1.A+B分为一组，将元素之和作为key，出现次数作为value放入map1
*2.c+D分为一组，将元素之和作为key，出现次数作为value放入map2
*3.遍历map1，寻找-k是否在map2中存在，乘积记录。
************************************************************************************************************
*/

/***********************************************************************************************************
给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。
************************************************************************************************************
*/

func fourSumCount(A []int, B []int, C []int, D []int) int {

    lenA := len(A)
    buffMap1 := make(map[int]int,lenA*lenA)
    buffMap2 := make(map[int]int,lenA*lenA)
    var count int

    for i := 0; i < lenA; i++ {
        for j := 0; j < lenA; j++ {
            buffMap1[A[i]+B[j]]++
        }        
    }

    for i := 0; i < lenA; i++ {
        for j := 0; j < lenA; j++ {
            buffMap2[C[i]+D[j]]++
        }        
    }

    for k, v := range buffMap1 {
        _, ok := buffMap2[0-k]
        if ok == true {
            count += v*buffMap2[0-k]
        }
    }

    return count

}