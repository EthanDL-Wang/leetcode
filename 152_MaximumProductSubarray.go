/***********************************************************************************************************
*执行用时：4 ms, 在所有 Go 提交中击败了90.70%的用户
*内存消耗：2.9 MB, 在所有 Go 提交中击败了16.17%的用户
*1.申请dp[][2]二维数组
*2.dp[0]放以nums[i]结尾，乘积最大的值
*3.dp[1]放以nums[i]结尾，乘积最小的值
*4.动态规划，搞起
*5.在dp[0]中找最大值
************************************************************************************************************
*/

/***********************************************************************************************************
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
************************************************************************************************************
*/


func maxProduct(nums []int) int {

    dp := make([][2]int, len(nums))

    dp[0][0] = nums[0]
    dp[0][1] = nums[0]

    result := dp[0][0]

    for i := 1; i < len(nums); i++ {

        if nums[i] == 0 || dp[i-1][0] == 0  {
            dp[i][0] = nums[i]
            dp[i][1] = nums[i]
            continue
        }     

        if nums[i] > 0 {


            if dp[i-1][0] > 0 && dp[i-1][1] > 0 {
                dp[i][0]=nums[i]*dp[i-1][0]
                dp[i][1]=nums[i]
            } else if dp[i-1][0] < 0 && dp[i-1][1] < 0 {
                dp[i][0]=nums[i]

                if dp[i-1][0] <= dp[i-1][1] {
                    dp[i][1]=nums[i]*dp[i-1][0]
                } else {
                    dp[i][1]=nums[i]*dp[i-1][1]
                }
 
            } else if dp[i-1][0] > 0 && dp[i-1][1] < 0 {
                dp[i][0]=nums[i]*dp[i-1][0]
                dp[i][1]=nums[i]*dp[i-1][1]
            } else if dp[i-1][0] < 0 && dp[i-1][1] > 0 {
                //never run here
            }

        } else if nums[i] < 0 {

            if dp[i-1][0] > 0 && dp[i-1][1] > 0 {
                dp[i][0]=nums[i]
                dp[i][1]=nums[i]*dp[i-1][0]
            } else if dp[i-1][0] < 0 && dp[i-1][1] < 0 {
                dp[i][0]=nums[i]*dp[i-1][1]
                dp[i][1]=nums[i]
            } else if dp[i-1][0] > 0 && dp[i-1][1] < 0 {
                dp[i][1]=nums[i]*dp[i-1][0]
                dp[i][0]=nums[i]*dp[i-1][1]
            } else if dp[i-1][0] < 0 && dp[i-1][1] > 0 {
                //never run here
            }
        }
    }

    for i := 1; i < len(nums); i++ {
        if result < dp[i][0] {
            result = dp[i][0]
        }
    }

    return result
}